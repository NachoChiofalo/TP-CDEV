<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Museo Virtual - Gran Sala</title>
  
  <style>
    /* Estilos generales */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Arial', sans-serif;
      background-color: #1a1a1a;
      color: white;
    }

    canvas {
      display: block;
      cursor: grab;
    }

    canvas:active {
      cursor: grabbing;
    }

    /* Interfaz de usuario */
    #interfazUsuario {
      position: fixed;
      top: 0;
      left: 0;
      z-index: 100;
      pointer-events: none;
    }

    #instrucciones {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px 20px;
      border-radius: 10px;
      border: 2px solid #d4af37;
      backdrop-filter: blur(10px);
      max-width: 300px;
    }

    #instrucciones h3 {
      color: #d4af37;
      margin-bottom: 10px;
      font-size: 16px;
    }

    #instrucciones p {
      margin: 5px 0;
      font-size: 14px;
      color: #e0e0e0;
    }

    #instrucciones strong {
      color: #d4af37;
    }

    /* Contador de FPS */
    #infoFPS {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px 15px;
      border-radius: 8px;
      border: 1px solid #d4af37;
      font-size: 14px;
      font-weight: bold;
      color: #d4af37;
    }

    /* Pantalla de bloqueo */
    #bloqueador {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #menuInicio {
      text-align: center;
      background: rgba(0, 0, 0, 0.9);
      padding: 40px;
      border-radius: 15px;
      border: 3px solid #d4af37;
      backdrop-filter: blur(10px);
      max-width: 400px;
    }

    #menuInicio h1 {
      color: #d4af37;
      font-size: 2.5em;
      margin-bottom: 20px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
    }

    /* Información de obras de arte */
    .info-obra {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 20px;
      border-radius: 10px;
      border: 2px solid #d4af37;
      max-width: 400px;
      text-align: center;
      display: none;
      z-index: 200;
    }

    .info-obra h3 {
      color: #d4af37;
      margin-bottom: 10px;
    }

    .info-obra p {
      margin: 5px 0;
      line-height: 1.4;
    }

    #menuInicio p {
      color: #e0e0e0;
      font-size: 1.2em;
      margin-bottom: 30px;
      line-height: 1.4;
    }

    #botonIniciar {
      background: linear-gradient(45deg, #d4af37, #f4d03f);
      color: #1a1a1a;
      border: none;
      padding: 15px 30px;
      font-size: 18px;
      font-weight: bold;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    #botonIniciar:hover {
      background: linear-gradient(45deg, #f4d03f, #d4af37);
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(212, 175, 55, 0.3);
    }

    #botonIniciar:active {
      transform: translateY(0);
    }

    /* Estado oculto */
    .oculto {
      display: none !important;
    }

    /* Responsive */
    @media (max-width: 768px) {
      #instrucciones {
        top: 10px;
        left: 10px;
        right: 10px;
        max-width: none;
        font-size: 12px;
      }
      
      #infoFPS {
        top: 10px;
        right: 10px;
        font-size: 12px;
      }
      
      #menuInicio {
        margin: 20px;
        padding: 30px;
      }
      
      #menuInicio h1 {
        font-size: 2em;
      }
    }
  </style>
</head>
<body>
  <!-- Interfaz de usuario -->
  <div id="interfazUsuario">
    <div id="instrucciones">
      <h3>Controles del Museo Virtual</h3>
      <p><strong>WASD:</strong> Moverse</p>
      <p><strong>Mouse:</strong> Mirar alrededor</p>
      <p><strong>Click:</strong> Activar controles</p>
      <p><strong>ESC:</strong> Salir del modo vista</p>
    </div>
    <div id="infoFPS">FPS: <span id="contadorFPS">60</span></div>
  </div>

  <!-- Canvas donde se renderiza la escena -->
  <canvas id="miCanvas"></canvas>

  <!-- Bloqueador para cuando se pierde el pointer lock -->
  <div id="bloqueador">
    <div id="menuInicio">
      <h1>Museo Virtual - Gran Sala</h1>
      <p>Explora esta galería con obras maestras del arte</p>
      <button id="botonIniciar">Entrar al Museo</button>
    </div>
  </div>

  <!-- Scripts -->

    <!-- Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>

    <!-- GLTFLoader -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

  
  <script>
    // Verificar que Three.js se haya cargado
    if (typeof THREE === 'undefined') {
      console.error('Three.js no se cargó correctamente');
      alert('Error cargando Three.js. Verifica la ruta del archivo.');
    } else {
      console.log('Three.js cargado correctamente, versión:', THREE.REVISION);
    }
  </script>
  <script>
    // ========================
    // CONFIGURACIÓN INICIAL
    // ========================

    // Variables principales de la escena
    let escena, camara, renderizador;
    let reloj;
    let objetosColision = [];
    let cargadorTexturas;

    // Variables de control
    let teclasPulsadas = {};
    let velocidadMovimiento = 5.0;

    // Variables de juego
    let cuadroGanador = null;
    let juegoTerminado = false;
    let meshCuadros = [];

    // Variables de rendimiento
    let ultimoTiempo = 0;
    let contadorFrames = 0;
    let tiempoFPS = 0;
    let debugPanel;

    // Variables de cámara
    let rotacionY = 0; // Horizontal (yaw)  
    let rotacionX = 0; // Vertical (pitch)
    let sensibilidadMouse = 0.002;

    // Dimensiones de la sala única
    const DIMENSIONES_SALA = {
        ancho: 60,
        alto: 6,
        profundo: 40
    };

    // ========================
// DEBUG PANEL - POSICIÓN EN TIEMPO REAL
// ========================

class DebugPanel {
    constructor() {
        this.panel = this.crearPanel();
        this.fps = 0;
        this.frameCount = 0;
        this.lastTime = performance.now();
    }
    
    crearPanel() {
        const panel = document.createElement('div');
        panel.style.cssText = `
            position: fixed;
            top: 60px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            color: #0f0;
            padding: 10px 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            border-radius: 5px;
            z-index: 1000;
            min-width: 180px;
            border: 1px solid #d4af37;
            user-select: none;
        `;
        panel.innerHTML = `
            <div style="margin-bottom: 5px; font-weight: bold; color: #d4af37;">DEBUG INFO</div>
            <div>Pos X: 0.00</div>
            <div>Pos Y: 0.00</div>
            <div>Pos Z: 0.00</div>
            <div>Rot Y: 0.00°</div>
        `;
        document.body.appendChild(panel);
        return panel;
    }
    
    calcularFPS(tiempoTranscurrido) {
        this.frameCount++;
        const currentTime = performance.now();
        
        if (currentTime >= this.lastTime + 1000) {
            this.fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastTime));
            this.frameCount = 0;
            this.lastTime = currentTime;
        }
        return this.fps;
    }
    
    actualizar(camara, tiempoTranscurrido) {
        const fps = this.calcularFPS(tiempoTranscurrido);
        const rotacionGrados = (camara.rotation.y * 180 / Math.PI).toFixed(1);
        
        this.panel.innerHTML = `
            <div style="margin-bottom: 5px; font-weight: bold; color: #d4af37;">DEBUG INFO</div>
            <div>Pos X: ${camara.position.x.toFixed(2)}</div>
            <div>Pos Y: ${camara.position.y.toFixed(2)}</div>
            <div>Pos Z: ${camara.position.z.toFixed(2)}</div>
            <div>Rot Y: ${rotacionGrados}°</div>
            <div style="margin-top: 5px; border-top: 1px solid #d4af37; padding-top: 5px;">
                FPS: ${fps}
            </div>
        `;
    }
}


    // ========================
    // INICIALIZACIÓN
    // ========================

    function inicializar() {
        console.log('Iniciando museo con sala única...');
        try {
            crearEscena();
            crearCamara();
            crearRenderizador();
            cargarModelo3D(); // CAMBIAR PORQUE CARGA EL MODELO LENTO Y SE TRABA
            cargarModelo3DBench();
            crearSalaUnica();
            crearIluminacion();
            
            // Inicializar cargador de texturas
            cargadorTexturas = new THREE.TextureLoader();
            
            
            crearObrasConTexturas();
            
            
            configurarControles();
            configurarEventos();
            
            reloj = new THREE.Clock();
            debugPanel = new DebugPanel();

            console.log('Museo con sala única inicializado');
            animar();
        } catch (error) {
            console.error('Error inicializando museo:', error);
        }
    }

    // ========================
    // CREACIÓN DE LA ESCENA
    // ========================

    function crearEscena() {
        escena = new THREE.Scene();
        escena.background = new THREE.Color(0x2a2a2a);
        escena.fog = new THREE.Fog(0x2a2a2a, 1, 40);
    }

    function crearCamara() {
        camara = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        camara.position.set(26, 1.6, 0);
        camara.rotation.order = 'YXZ'; // Importante para evitar gimbal lock
    }

    function crearRenderizador() {
        console.log('Creando renderizador optimizado...');
        renderizador = new THREE.WebGLRenderer({
            canvas: document.querySelector("#miCanvas"),
            antialias: true
        });
        
        renderizador.setSize(window.innerWidth, window.innerHeight);
        renderizador.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderizador.shadowMap.enabled = false;
        renderizador.outputEncoding = THREE.sRGBEncoding;
    }

    // ========================
    // CREACIÓN DE LA SALA ÚNICA
    // ========================

    function crearSalaUnica() {
        console.log('Construyendo sala única grande...');

        //Textura piso
        const texturaSuelo = new THREE.TextureLoader().load("assets/texturas/checkered_pavement_tiles_diff_1k.jpg");
        texturaSuelo.wrapS = THREE.RepeatWrapping;
        texturaSuelo.wrapT = THREE.RepeatWrapping;
        texturaSuelo.repeat.set(6, 6); // Ajusta el número de repeticiones según el tamaño del piso

        //Textura pared
        const texturaPared = new THREE.TextureLoader().load("assets/texturas/marble_01_diff_2k.jpg");
        texturaPared.wrapS = THREE.RepeatWrapping;
        texturaPared.wrapT = THREE.RepeatWrapping;
        texturaPared.repeat.set(2, 2);

        // Materiales
        const materialPared = new THREE.MeshLambertMaterial({ map: texturaPared, side: THREE.DoubleSide });
        const materialSuelo = new THREE.MeshLambertMaterial({ map: texturaSuelo });
        const materialTecho = new THREE.MeshLambertMaterial({ color: 0xfafafa });
        
        // CUADRADO

        const { ancho, alto, profundo } = DIMENSIONES_SALA;
        
        // Suelo
        const suelo = new THREE.Mesh(
            new THREE.PlaneGeometry(ancho, profundo),
            materialSuelo
        );
        suelo.rotation.x = -Math.PI / 2;
        suelo.position.set(0, 0.01, 0);
        escena.add(suelo);
        
        // Techo
        const techo = new THREE.Mesh(
            new THREE.PlaneGeometry(ancho, profundo),
            materialTecho
        );
        techo.rotation.x = Math.PI / 2;
        techo.position.set(0, alto - 0.01, 0);
        escena.add(techo);
        
        // Pared norte
        const paredNorte = new THREE.Mesh(
            new THREE.PlaneGeometry(ancho, alto),
            materialPared
        );
        paredNorte.position.set(0, alto / 2, -profundo / 2 + 0.01);
        escena.add(paredNorte);
        objetosColision.push({tipo: 'pared', z: -profundo / 2});
        
        // Pared sur
        const paredSur = new THREE.Mesh(
            new THREE.PlaneGeometry(ancho, alto),
            materialPared
        );
        paredSur.position.set(0, alto / 2, profundo / 2 - 0.01);
        paredSur.rotation.y = Math.PI;
        escena.add(paredSur);
        objetosColision.push({tipo: 'pared', z: profundo / 2});
        
        // Pared este
        const paredEste = new THREE.Mesh(
            new THREE.PlaneGeometry(profundo, alto),
            materialPared
        );
        paredEste.position.set(ancho / 2 - 0.01, alto / 2, 0);
        paredEste.rotation.y = -Math.PI / 2;
        escena.add(paredEste);
        objetosColision.push({tipo: 'pared', x: ancho / 2});
        
        // Pared oeste
        const paredOeste = new THREE.Mesh(
            new THREE.PlaneGeometry(profundo, alto),
            materialPared
        );
        paredOeste.position.set(-ancho / 2 + 0.01, alto / 2, 0);
        paredOeste.rotation.y = Math.PI / 2;
        escena.add(paredOeste);
        objetosColision.push({tipo: 'pared', x: -ancho / 2});


        //CUADRADO 1

        const paredMedioDer = new THREE.Mesh(
            new THREE.PlaneGeometry(15, alto),
            materialPared
        )
        paredMedioDer.position.set(-4.5,alto/2,-12.5);
        paredMedioDer.rotation.y = Math.PI / 2;
        escena.add(paredMedioDer);
        objetosColision.push({tipo: 'pared', x: -4.5, zMin: -20, zMax: -5}); // ← COLISIÓN


        const paredPasilloPuertaDer1 = new THREE.Mesh(
            new THREE.PlaneGeometry(10, alto),
            materialPared
        )
        paredPasilloPuertaDer1.position.set(-25,alto/2,-5);
        escena.add(paredPasilloPuertaDer1);
        objetosColision.push({tipo: 'pared', z: -5, xMin: -30, xMax: -20}); // ← COLISIÓN



        const paredPasilloPuertaDer2 = new THREE.Mesh(
            new THREE.PlaneGeometry(10, alto),
            materialPared
        )
        paredPasilloPuertaDer2.position.set(-9.5,alto/2,-5);
        escena.add(paredPasilloPuertaDer2);
        objetosColision.push({tipo: 'pared', z: -5, xMin: -14.5, xMax: -4.5}); // ← COLISIÓN


        // CUADRADO 2 

        const paredFrontDer = new THREE.Mesh(
            new THREE.PlaneGeometry(15, alto),
            materialPared
        )
        paredFrontDer.position.set(20.5,alto/2,-12.5);
        paredFrontDer.rotation.y = Math.PI / 2;
        escena.add(paredFrontDer);
        objetosColision.push({tipo: 'pared', x: 20.5, zMin: -20, zMax: -5}); // ← COLISIÓN


        const paredPasilloPuertaDer3 = new THREE.Mesh(
            new THREE.PlaneGeometry(10, alto),
            materialPared
        )
        paredPasilloPuertaDer3.position.set(0,alto/2,-5);
        escena.add(paredPasilloPuertaDer3);
        objetosColision.push({tipo: 'pared', z: -5, xMin: -5, xMax: 5}); // ← COLISIÓN


        const paredPasilloPuertaDer4 = new THREE.Mesh(
            new THREE.PlaneGeometry(10, alto),
            materialPared
        )
        paredPasilloPuertaDer4.position.set(15.5,alto/2,-5);
        escena.add(paredPasilloPuertaDer4);
        objetosColision.push({tipo: 'pared', z: -5, xMin: 10.5, xMax: 20.5}); // ← COLISIÓN

        // CUADRADO 3

        const paredMedioIzq = new THREE.Mesh(
            new THREE.PlaneGeometry(15, alto),
            materialPared
        )
        paredMedioIzq.position.set(-4.5,alto/2,12.5);
        paredMedioIzq.rotation.y = Math.PI / 2;
        escena.add(paredMedioIzq);
        objetosColision.push({tipo: 'pared', x: -4.5, zMin: 5, zMax: 20}); // ← COLISIÓN


        const paredPasilloPuertaIzq1 = new THREE.Mesh(
            new THREE.PlaneGeometry(10, alto),
            materialPared
        )
        paredPasilloPuertaIzq1.position.set(-25,alto/2,5);
        escena.add(paredPasilloPuertaIzq1);
        objetosColision.push({tipo: 'pared', z: 5, xMin: -30, xMax: -20}); // ← COLISIÓN


        const paredPasilloPuertaIzq2 = new THREE.Mesh(
            new THREE.PlaneGeometry(10, alto),
            materialPared
        )
        paredPasilloPuertaIzq2.position.set(-9.5,alto/2,5);
        escena.add(paredPasilloPuertaIzq2);
        objetosColision.push({tipo: 'pared', z: 5, xMin: -14.5, xMax: -4.5}); // ← COLISIÓN



        // CUADRADO 4



        const paredFrontIzq = new THREE.Mesh(
            new THREE.PlaneGeometry(15, alto),
            materialPared
        )
        paredFrontIzq.position.set(20.5,alto/2,12.5);
        paredFrontIzq.rotation.y = Math.PI / 2;
        escena.add(paredFrontIzq);
        objetosColision.push({tipo: 'pared', x: 20.5, zMin: 5, zMax: 20}); // ← COLISIÓN


        const paredPasilloPuertaIzq3 = new THREE.Mesh(
            new THREE.PlaneGeometry(10, alto),
            materialPared
        )
        paredPasilloPuertaIzq3.position.set(0,alto/2,5);
        escena.add(paredPasilloPuertaIzq3);
        objetosColision.push({tipo: 'pared', z: 5, xMin: -5, xMax: 5}); // ← COLISIÓN

        const paredPasilloPuertaIzq4 = new THREE.Mesh(
            new THREE.PlaneGeometry(10, alto),
            materialPared
        )
        paredPasilloPuertaIzq4.position.set(15.5,alto/2,5);
        escena.add(paredPasilloPuertaIzq4);
        objetosColision.push({tipo: 'pared', z: 5, xMin: 10.5, xMax: 20.5}); // ← COLISIÓN

        // Columnas decorativas
        crearColumnasDecorativas();
    }


    function crearColumnasDecorativas() {
        const materialColumna = new THREE.MeshLambertMaterial({ color: 0xd4af37 });
        const geometriaColumna = new THREE.CylinderGeometry(0.5, 0.5, DIMENSIONES_SALA.alto, 16);
        
        // Crear columnas en las esquinas
        const posicionesColumnas = [
            { x: -DIMENSIONES_SALA.ancho/2 + 1, z: -DIMENSIONES_SALA.profundo/2 + 1 },
            { x: DIMENSIONES_SALA.ancho/2 - 1, z: -DIMENSIONES_SALA.profundo/2 + 1 },
            { x: -DIMENSIONES_SALA.ancho/2 + 1, z: DIMENSIONES_SALA.profundo/2 - 1 },
            { x: DIMENSIONES_SALA.ancho/2 - 1, z: DIMENSIONES_SALA.profundo/2 - 1 }
        ];
        
        posicionesColumnas.forEach(pos => {
            const columna = new THREE.Mesh(geometriaColumna, materialColumna);
            columna.position.set(pos.x, DIMENSIONES_SALA.alto/2, pos.z);
            escena.add(columna);
        });
    }

    // ========================
    // ILUMINACIÓN
    // ========================

    function crearIluminacion() {
        // Luz ambiental
        const luzAmbiental = new THREE.AmbientLight(0x404040, 0.5);
        escena.add(luzAmbiental);
        
        // Luces direccionales principales
        const luzPrincipal1 = new THREE.DirectionalLight(0xffffff, 0.8);
        luzPrincipal1.position.set(10, DIMENSIONES_SALA.alto, 10);
        escena.add(luzPrincipal1);
        
        const luzPrincipal2 = new THREE.DirectionalLight(0xffffff, 0.8);
        luzPrincipal2.position.set(-10, DIMENSIONES_SALA.alto, -10);
        escena.add(luzPrincipal2);
        
        // Luces focales para las obras
        const luzFocal1 = new THREE.SpotLight(0xffffff, 1, 20, Math.PI/6, 0.5);
        luzFocal1.position.set(0, DIMENSIONES_SALA.alto - 1, 0);
        luzFocal1.target.position.set(0, 0, 0);
        escena.add(luzFocal1);
        escena.add(luzFocal1.target);
    }


    // MODELO 3D - THINKER
   function cargarModelo3D() {
    console.log('Cargando modelo 3D...');
    
    const loader = new THREE.GLTFLoader();
    
    // PRIMERO: Usar el modelo de prueba para confirmar que todo funciona
    // LUEGO: Reemplazar con la ruta correcta a tu modelo local
    
    // Opción 1: Modelo de prueba (funciona)
    const rutaModelo = 'assets/models/scene.gltf';
    
    // Opción 2: Tu modelo local (debes ajustar la ruta correcta)
    // const rutaModelo = 'assets/texturas/models/scene.gltf';
    // const rutaModelo = 'tpFinal/assets/texturas/models/scene.gltf';
    
    loader.load(
        rutaModelo,
        function(gltf) {
            console.log('Modelo 3D cargado correctamente');
            
            // Obtener el modelo
            const modelo = gltf.scene;
            
            // Ajustar posición, escala y rotación
            modelo.position.set(-13, 1, 0);
            modelo.scale.set(2.0, 2.0, 2.0);
            modelo.rotation.y = Math.PI;
            
            // Agregar a la escena
            escena.add(modelo);
            
            // Crear base para la escultura
            const geometriaBase = new THREE.BoxGeometry(3, 2.5, 2);
            const materialBase = new THREE.MeshLambertMaterial({ color: 0x888888 });
            const base = new THREE.Mesh(geometriaBase, materialBase);
            base.position.set(-13, 0, 0);
            escena.add(base);
            
            console.log('Escultura agregada correctamente');
        },
        function(xhr) {
            // Progreso de carga
            console.log((xhr.loaded / xhr.total * 100) + '% cargado');
        },
        function(error) {
            console.error('Error al cargar el modelo:', error);
            
            // Mensaje de error en pantalla
            const divError = document.createElement('div');
            divError.style.position = 'fixed';
            divError.style.bottom = '20px';
            divError.style.left = '50%';
            divError.style.transform = 'translateX(-50%)';
            divError.style.backgroundColor = 'rgba(200, 0, 0, 0.8)';
            divError.style.color = 'white';
            divError.style.padding = '10px 20px';
            divError.style.borderRadius = '5px';
            divError.style.zIndex = '10000';
            divError.style.textAlign = 'center';
            divError.innerHTML = '<h3>Error al cargar el modelo 3D</h3>' +
                                '<p>Verifica la ruta del archivo: ' + rutaModelo + '</p>';
            document.body.appendChild(divError);
            
            // Eliminar el mensaje después de 5 segundos
            setTimeout(() => {
                if (document.body.contains(divError)) {
                    document.body.removeChild(divError);
                }
            }, 5000);
        }
    );
}

function cargarModelo3DBench() {
    console.log('Cargando modelo 3D...');
    
    const loader = new THREE.GLTFLoader();
    
    // PRIMERO: Usar el modelo de prueba para confirmar que todo funciona
    // LUEGO: Reemplazar con la ruta correcta a tu modelo local
    
    // Opción 1: Modelo de prueba (funciona)
    const rutaModelo = 'assets/models/bench.gltf';
    
    // Opción 2: Tu modelo local (debes ajustar la ruta correcta)
    // const rutaModelo = 'assets/texturas/models/scene.gltf';
    // const rutaModelo = 'tpFinal/assets/texturas/models/scene.gltf';
    
    loader.load(
        rutaModelo,
        function(gltf) {
            console.log('Modelo 3D cargado correctamente');
            
            // Obtener el modelo
            const modelo = gltf.scene;
            
            // Ajustar posición, escala y rotación
            modelo.position.set(25, 1, 0);
            modelo.scale.set(2.0, 2.0, 2.0);
            modelo.rotation.y = Math.PI;
            
            // Agregar a la escena
            escena.add(modelo);
        
            
            console.log('Escultura agregada correctamente');
        },
        function(xhr) {
            // Progreso de carga
            console.log((xhr.loaded / xhr.total * 100) + '% cargado');
        },
        function(error) {
            console.error('Error al cargar el modelo:', error);
            
            // Mensaje de error en pantalla
            const divError = document.createElement('div');
            divError.style.position = 'fixed';
            divError.style.bottom = '20px';
            divError.style.left = '50%';
            divError.style.transform = 'translateX(-50%)';
            divError.style.backgroundColor = 'rgba(200, 0, 0, 0.8)';
            divError.style.color = 'white';
            divError.style.padding = '10px 20px';
            divError.style.borderRadius = '5px';
            divError.style.zIndex = '10000';
            divError.style.textAlign = 'center';
            divError.innerHTML = '<h3>Error al cargar el modelo 3D</h3>' +
                                '<p>Verifica la ruta del archivo: ' + rutaModelo + '</p>';
            document.body.appendChild(divError);
            
            // Eliminar el mensaje después de 5 segundos
            setTimeout(() => {
                if (document.body.contains(divError)) {
                    document.body.removeChild(divError);
                }
            }, 5000);
        }
    );
}

    // ========================
    // CREACIÓN DE OBRAS CON TEXTURAS
    // ========================

    function crearObrasConTexturas() {
        console.log('Cargando obras de arte...');


        //PARED NORTE
        const textura = new THREE.TextureLoader().load("assets/texturas/capilla_sixtina.webp");

        const material = new THREE.MeshBasicMaterial({ map: textura });
        const geometria = new THREE.PlaneGeometry(4.0, 3.0);

        const pintura = new THREE.Mesh(geometria, material);
        pintura.position.set(15, 2.5, -4.9);

        // Girar 90 grados
        //monaLisa.rotation.y = Math.PI / 2; // Gira alrededor del eje Y

        escena.add(pintura);


        const textura1 = new THREE.TextureLoader().load("assets/texturas/cuadro_extra6.webp");

        const material1 = new THREE.MeshBasicMaterial({ map: textura1 });
        const geometria1 = new THREE.PlaneGeometry(4.0, 3.0);

        const pintura1 = new THREE.Mesh(geometria1, material1);
        pintura1.position.set(0, 2.5, -4.9);

        // Girar 90 grados
        //monaLisa.rotation.y = Math.PI / 2; // Gira alrededor del eje Y

        escena.add(pintura1);


        const textura2 = new THREE.TextureLoader().load("assets/texturas/las_meninas.webp");

        const material2 = new THREE.MeshBasicMaterial({ map: textura2 });
        const geometria2 = new THREE.PlaneGeometry(4.0, 3.0);

        const pintura2 = new THREE.Mesh(geometria2, material2);
        pintura2.position.set(-8, 2.5, -4.9);

        // Girar 90 grados
        //monaLisa.rotation.y = Math.PI / 2; // Gira alrededor del eje Y

        escena.add(pintura2);



        // PARED SUR

        const textura3 = new THREE.TextureLoader().load("assets/texturas/noche_estrellada.webp");

        const material3 = new THREE.MeshBasicMaterial({ map: textura3 });
        const geometria3 = new THREE.PlaneGeometry(4.0, 3.0);

        const pintura3 = new THREE.Mesh(geometria3, material3);
        pintura3.position.set(-8, 2.5, 4.9);

        // Girar 90 grados
        pintura3.rotation.y = Math.PI; // Gira alrededor del eje Y

        escena.add(pintura3);
        

        const textura4 = new THREE.TextureLoader().load("assets/texturas/cuadro_extra4.webp");

        const material4 = new THREE.MeshBasicMaterial({ map: textura4 });
        const geometria4 = new THREE.PlaneGeometry(4.0, 3.0);

        const pintura4 = new THREE.Mesh(geometria4, material4);
        pintura4.position.set(0, 2.5, 4.9);

        // Girar 90 grados
        pintura4.rotation.y = Math.PI; // Gira alrededor del eje Y

        escena.add(pintura4);

        const textura5 = new THREE.TextureLoader().load("assets/texturas/girl_pearl_earring.webp");

        const material5 = new THREE.MeshBasicMaterial({ map: textura5 });
        const geometria5 = new THREE.PlaneGeometry(4.0, 3.0);

        const pintura5 = new THREE.Mesh(geometria5, material5);
        pintura5.position.set(15, 2.5, 4.9);

        // Girar 90 grados
        pintura5.rotation.y = Math.PI; // Gira alrededor del eje Y

        escena.add(pintura5);

        /* obrasDeArte.forEach((obra, indice) => {
            if (obra.textura) {
                crearObraConTextura(obra, indice);
            } else {
                crearObraConColor(obra, indice);
            }
        }); */

        
    }



    // ========================
    // CONTROLES
    // ========================

    function configurarControles() {
        const bloqueador = document.getElementById('bloqueador');
        const botonIniciar = document.getElementById('botonIniciar');
        
        botonIniciar.addEventListener('click', function() {
            console.log('Iniciando recorrido...');
            const elemento = document.body;
            
            elemento.requestPointerLock = elemento.requestPointerLock || 
                                        elemento.mozRequestPointerLock || 
                                        elemento.webkitRequestPointerLock;
            
            if (elemento.requestPointerLock) {
                elemento.requestPointerLock();
            } else {
                bloqueador.style.display = 'none';
            }
        });
        
        document.addEventListener('pointerlockchange', cambiarPointerLock);
        document.addEventListener('mozpointerlockchange', cambiarPointerLock);
        document.addEventListener('webkitpointerlockchange', cambiarPointerLock);
        
        function cambiarPointerLock() {
            const elemento = document.pointerLockElement || 
                            document.mozPointerLockElement || 
                            document.webkitPointerLockElement;
            
            if (elemento === document.body) {
                bloqueador.style.display = 'none';
            } else {
                bloqueador.style.display = 'flex';
            }
        }
    }

    function configurarEventos() {
        // Teclado
        document.addEventListener('keydown', function(evento) {
            teclasPulsadas[evento.code] = true;
        });
        
        document.addEventListener('keyup', function(evento) {
            teclasPulsadas[evento.code] = false;
        });
        
        // Mouse
        document.addEventListener('mousemove', function(evento) {
            if (document.pointerLockElement === document.body) {
                const movimientoX = evento.movementX || 0;
                const movimientoY = evento.movementY || 0;
                
                // Actualizar rotaciones
                rotacionY -= movimientoX * sensibilidadMouse;
                rotacionX -= movimientoY * sensibilidadMouse;
                
                // Limitar pitch
                rotacionX = Math.max(-Math.PI / 2.2, Math.min(Math.PI / 2.2, rotacionX));
                
                // Aplicar rotación a la cámara
                camara.rotation.y = rotacionY;
                camara.rotation.x = rotacionX;
                camara.rotation.z = 0;
            }
        });
        
        // Redimensionar
        window.addEventListener('resize', function() {
            camara.aspect = window.innerWidth / window.innerHeight;
            camara.updateProjectionMatrix();
            renderizador.setSize(window.innerWidth, window.innerHeight);
        });
    }

    // ========================
    // MOVIMIENTO
    // ========================

    function actualizarMovimiento(tiempoDelta) {
        if (juegoTerminado) return;
        
        const velocidad = velocidadMovimiento * tiempoDelta;
        const direccion = new THREE.Vector3();
        
        // Obtener dirección de entrada
        if (teclasPulsadas['KeyW']) direccion.z = -1;  // Forward
        if (teclasPulsadas['KeyS']) direccion.z = 1; // Backward  
        if (teclasPulsadas['KeyA']) direccion.x = -1;  // Left
        if (teclasPulsadas['KeyD']) direccion.x = 1; // Right
        
        if (direccion.length() === 0) return; // No hay movimiento
        
        direccion.normalize();
        
        // Aplicar rotación Y (horizontal) a la dirección
        const cos = Math.cos(rotacionY);
        const sin = Math.sin(rotacionY);
        
        const direccionMundial = new THREE.Vector3(
            direccion.x * cos + direccion.z * sin,
            0,
            -direccion.x * sin + direccion.z * cos
        );
        
        // Calcular nueva posición
        const nuevaPosicion = camara.position.clone();
        nuevaPosicion.add(direccionMundial.multiplyScalar(velocidad));
        
        // Verificar colisiones y aplicar
        if (verificarColisiones(nuevaPosicion)) {
            camara.position.copy(nuevaPosicion);
        }
        
        // Verificar condición de victoria
        //verificarVictoria();
    }

    /* function verificarColisiones(nuevaPosicion) {
        const margen = 0.5;
        const { ancho, profundo } = DIMENSIONES_SALA;
        
        // Límites de la sala
        if (nuevaPosicion.x < -ancho/2 + margen || nuevaPosicion.x > ancho/2 - margen) return false;
        if (nuevaPosicion.z < -profundo/2 + margen || nuevaPosicion.z > profundo/2 - margen) return false;
        
        return true;
    } */

    function verificarColisiones(nuevaPosicion) {
    const margen = 0.5;
    const { ancho, profundo } = DIMENSIONES_SALA;
    
    // 1. Verificar límites de la sala principal
    if (nuevaPosicion.x < -ancho/2 + margen || nuevaPosicion.x > ancho/2 - margen) return false;
    if (nuevaPosicion.z < -profundo/2 + margen || nuevaPosicion.z > profundo/2 - margen) return false;
    
    // 2. Verificar colisión con todas las paredes internas
    for (const pared of objetosColision) {
        if (pared.tipo === 'pared') {
            // Paredes en eje Z (norte/sur)
            if (pared.z !== undefined) {
                const distanciaZ = Math.abs(nuevaPosicion.z - pared.z);
                if (distanciaZ < margen) {
                    // Verificar límites en X para esta pared
                    const dentroDeLimites = !pared.xMin || 
                                          (nuevaPosicion.x >= pared.xMin && nuevaPosicion.x <= pared.xMax);
                    if (dentroDeLimites) {
                        return false;
                    }
                }
            }
            
            // Paredes en eje X (este/oeste)
            if (pared.x !== undefined) {
                const distanciaX = Math.abs(nuevaPosicion.x - pared.x);
                if (distanciaX < margen) {
                    // Verificar límites en Z para esta pared
                    const dentroDeLimites = !pared.zMin || 
                                          (nuevaPosicion.z >= pared.zMin && nuevaPosicion.z <= pared.zMax);
                    if (dentroDeLimites) {
                        return false;
                    }
                }
            }
        }
    }
    
    return true;
}

    // ========================
    // RENDIMIENTO
    // ========================

    function actualizarFPS(tiempoTranscurrido) {
        contadorFrames++;
        tiempoFPS += tiempoTranscurrido;
        
        if (tiempoFPS >= 1000) {
            const fps = Math.round((contadorFrames * 1000) / tiempoFPS);
            document.getElementById('contadorFPS').textContent = fps;
            contadorFrames = 0;
            tiempoFPS = 0;
        }
    }

    // PRUEBASSSSS

    





    // ========================
    // DETECCIÓN DE VICTORIA
    // ========================

    function verificarVictoria() {
        if (juegoTerminado) return;
        
        // Buscar el cuadro ganador en la lista de meshes
        const cuadroGanadorData = meshCuadros.find(cuadro => cuadro.datos.esGanador);
        
        if (!cuadroGanadorData) {
            console.log('No se encontró cuadro ganador');
            return;
        }
        
        const posicionJugador = camara.position;
        const posicionCuadro = cuadroGanadorData.posicion;
        
        const distancia = posicionJugador.distanceTo(posicionCuadro);
        
        console.log(`Distancia al cuadro ganador: ${distancia.toFixed(2)}`);
        
        if (distancia < 3.0) {
            console.log('¡Victoria detectada!');
            //mostrarVictoria(cuadroGanadorData.datos);
        }
    }

    
    
    // ========================
    // BUCLE PRINCIPAL
    // ========================

    function animar(tiempoActual) {
        requestAnimationFrame(animar);
        
        const tiempoDelta = reloj.getDelta();
        const tiempoTranscurrido = tiempoActual - ultimoTiempo;
        ultimoTiempo = tiempoActual;
        
        actualizarMovimiento(tiempoDelta);
        actualizarFPS(tiempoTranscurrido);
        
        if (debugPanel) {
        debugPanel.actualizar(camara, tiempoTranscurrido);
        }

        renderizador.render(escena, camara);
    }

    // ========================
    // INICIO
    // ========================

    document.addEventListener('DOMContentLoaded', function() {
        console.log('Inicializando museo con sala única...');
        if (typeof THREE === 'undefined') {
            console.error('Three.js no cargado');
            return;
        }
        inicializar();
    });

    if (document.readyState !== 'loading') {
        inicializar();
    }
  </script>
</body>
</html>